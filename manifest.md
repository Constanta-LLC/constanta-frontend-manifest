# Манифест frontend разработчика Constanta

Здесь описаны основные принципы, понятия которых мы придерживаемся в нашей работе.

Также здесь описаны некоторые моменты касающиеся стилистики (**орфографии кода**). Документ ориентирован на новых (**в компании**) разработчиков. С помощью манифеста мы сможем быстро погрузить новичка в те принципы и мысли, с которыми мы работаем.

Текущим разработчикам также нужно начать следовать его примеру. Документ не является сводом "законов" и носит *строго рекомендательный* характер. Но конечно, желательно ему следовать :)

Манифест будет разбит на несколько разделов, первый из которых - Синтаксис.

## Базовый синтаксис (JavaScript, TypeScript)

### Отступы, переносы

- Для отступов мы используем пробелы. **Табы не используются**.

- В случае отступа от переменных или других ключевых слов, мы используем один пробел. Мы не выравниваем наш код по одной колонке.

```jsx
// Плохо

const testVariable     = 'test';
const longTestVariable = 'test2';

// Хорошо

const testVariable = 'test';
const longTestVariable = 'test';
```

**Исключение!**

Если характер объявленных переменных / данных имеет однотипную семантику, то правило выше **допускается** не использовать. **Но только в одном этом случае.**

```jsx
const SPORTS: Record<string, ISportUI> = {
  1:    { icon: 'football',
  5:    { icon: 'baseball',
  6:    { icon: 'american_football',
  16:   { icon: 'rugby',
  1439: { icon: 'field_hockey',
  6596: { icon: 'cricket',
 }
```

- Открывающие скобки блоков кода (функций, условных выражений, циклов) **ВСЕГДА** находятся на одной строке с оператором:

```jsx
// Плохо

if (someCondition) 
{
 // some stuff
}

if (someCondition) { // some stuff }

if (someCondition) // some stuff

if (condition) 
  console.log('if')
else 
 console.log('else')

// Хорошо
  
if (someCondition) {
  // some stuff
}

if (condition) {
  console.log('if')
} else {
  console.log('else')
}
```

- Ключевые слова в языке, синтаксические конструкции (разные по характеру), структуры типов разделяются в коде не более и не менее одной строкой.

```tsx
// Плохо

import { app } from './app';
interface SomeResult {
  readonly id: number;
}
const someResult: SomeResult = { id: 1 }

function createRequest(): void {
  const xhr = new XMLHTTPRequest();

  return xhr;
}
for (let i = 0; i <= 5; i += 1) {
  const xhr = createRequest();

  xhr.open();
  app.log();
}

// Хорошо

import { app } from './app';

interface SomeResult {
  readonly id: number;
}

const someResult: SomeResult = { id: 1 }

function createRequest(): void {
  const xhr = new XMLHTTPRequest();

  return xhr;
}

for (let i = 0; i <= 5; i += 1) {
  const xhr = createRequest();

  xhr.open();
  app.log();
}
```

**Исключение!**

- Импорты из файлов библиотек, и импорты из файлов проекта должны разделяться между собой пустой строкой.

```tsx
// Плохо

import { Stuff } from './utils/stuff';
import * as lib from 'lib';
import Vue from 'vue';
import transform from './utils/transform';

// Хорошо

// Сначала глобальные либы.
import * as lib from 'lib';
import Vue from 'vue';
// Потом файлы проекта.
import { Stuff } from './utils/stuff';
import transform from './utils/transform';
```

- В функциях, и блоках кода (`for/while/if`) код НЕ должен начинаться и заканчиваться с пустой строки.

```tsx
// Плохо

const getRandomArrayElement = (arr) => {

  const i = Math.floor(Math.random() * arr.length);
  const random = arr[i];

  return random;

},

for (const user of users) {

  user.update():
}

// Хорошо

const getRandomArrayElement = (arr) => {
  const i = Math.floor(Math.random() * arr.length);
  const random = arr[i];

  return random;
},

for (const user of users) {
  user.update();
}

```

## Строки

- Мы не используем двойные кавычки. Разрешено использование двойных кавычек только в случае если одинарные кавычки являются частью строки.

```tsx
// Допускается

const userConfirmationText = "'Submut'"
```

- Для переноса мы используем обратные кавычки  (`template-literals`) Запрещено использовать одинарные кавычки для переносов.

```tsx
// Плохо

const text = 'Для переноса мы используем' +
  'обратные кавычки' +
  'не допускается использование одинарных' +
  ''

// Хорошо

const text = `Для переноса мы используем
обратные кавычки
не допускатеся использование одинарные`
```

## Именование

- Все переменные должны быть названы в **camelCase** регистре.

```tsx
// Плохо

const very_long_variable_name = 'name'; // Даже если вы фанат Python.
const VeryLongVariableName = 'name';
const VERYLONGVARIABLENAME = 'name';

// Хорошо

const veryLongVariableName = 'name';

const VERY_LONG_VARIABLE_NAME = 'name'; // Справедливо для констант
```

Исключение!

Допускается именование в стиле **CONSTANT_CASE** для констант.  Для классов (`class`) и перечислений (`enum`) - **PascalCase**

```tsx
// Допускается

// CONSTANT_CASE

const TEST_API_ENDPOINT = 'https://url.com';
const MAX_USER_COUNT = 5;

// PascalCase

class Glyph {
  render() {}
}

class Polygon extends Glyph {}

enum Color {
  Red = 1,
  Green = 2,
  Blue = 3,
}
```

### Обработка ошибок и исключений

Ошибки - это часть работы программы. Ошибка которая хорошо описывает себя - это способ уменьшить количество времени потраченной на нее.

Ошибки в JavaScript - это отдельная тема для обсуждения, поэтому здесь описаны лишь малая, но важная часть вещей о которых нужно помнить когда работаешь исключениями.

- При использование оператора `throw` мы передаем только объект `Error` или его потомков.

```tsx
// Плохо

const api = getApiInstance();

function loadApi() {
  if (!api) {
    throw 'No Api found';
  }
}

const api = getApiInstance();

function loadApi() {
  if (!api) {
    const errorName = 'ApiError';

    const errorMessage = 'No Api found';

    throw [apiErrorName, errorMessage];
  }
}

// Хорошо**

const api = getApiInstance();

function loadApi() {
  if (!api) {
    throw new Error('No Api found');
  }
}
```

- Запрещено оставлять пустой блок `catch` при обработке ошибок. Это приводит к очень печальным последствиям: код не работает, но сообщение в логах / консоли не отображается. Также не рекомендуется использовать конструкцию `try/catch` без явной нужды.

```tsx
// Плохо

try {
  await loadApi();
} catch (error) {
 // Ошибка погибнет здесь и не поднимается по стеку вызовов.
}

try {
  await loadApi();
} catch {
  console.log('error happened'); 
  // Тоже плохо, не особо понятно по итогу что это за ошибка.
  // Вывод ошибки в консоль является допустим в режиме разработки,
  // но не в продакшене.
}

try {
  await loadApi();
} catch (error) {
  throw error; // Бесполезный catch
}

loadApi()
  .then(() => {})
  .catch(() => {});

// Все выше аналогично и для then/catch конструкций.

// Хорошо

loadApi(); // Если ошибку не нужно обрабатывать, то try / catch нам здесь и не нужен!

try {
  await loadApi();
} catch (error) {
  this.isError = true;
  this.errorMessage = error.message;
}

try {
  await loadApi();
} catch (error) {
  log(error.name, error.message);

  throw error;

  // Здесь мы обработали ошибку на текущем уровне вызова (залогировали),
  // и пробросили ее выше, чтобы обработать дальше. 
  // (Например вывести оповещение пользователю)
}
```

## Синтаксис VueJS компонентов

Изначально, мы стараемся придерживаться официального VueJS стайлгайда - https://v3.ru.vuejs.org/ru/style-guide/. Здесь будет указаны основные моменты, на которые хочется обратить внимание,
и некоторые вещи будут описаны с нуля.

- Типизация props у компонентов. Нужно стараться указать только один тип у реиспользуемого в нескольких местах компонента. Если например формат данных выглядит как число: `const userId = 123`, то нужно его везде использовать как int. Если где-то эти данные приходят вам в виде строки `const userId=456`, но вы можете сделать его числом - лучше заранее это сделать, а Vue компонент отдавать данные одного формата. 

```tsx
// Плохо

props: {
  userId: {
    type: [Number, String] // Плохо, так как то Number передается, то String. Занимайтесь преобразованием ваших данных к единому формату как можно раньше.
  }
}

// Хорошо

props: {
  userId: {
    type: Number // Хорошо, так как то userId передается всегда в одном формате, и эти данные ведут себя более предсказуемо.
  }
}
```

Аналогичный пример с Object vs Array. Например какие-то данные могут придти в единственном числе, а иногда и сразу в нескольких.
В этом случае лучше данные явно привести к какому-то одному типу, которые лучше согласуется со всем остальным.

```tsx
// Плохо

props: {
  data: {
    type: [Object, Array] // Плохо, так как то Number передается, то String. Занимайтесь преобразованием ваших данных к единому формату как можно раньше.
  }
}

// Хорошо

props: {
  data: {
    type: Array // Хорошо, так как то userId передается всегда в одном формате, и эти данные ведут себя более предсказуемо.
  }
}
```

- Именование props у компонентов и использование их в шаблоне. При именование props - мы используем camelCase, при использование их в шаблоне - kebab-case.

```tsx
// Плохо

props: {
  SomePropName,
  'some-prop-name'
}

// Хорошо

props: {
  somePropName,
}
```

```tsx
// Плохо

<MyComponent :isGreen="name"/> 
<MyComponent :hasActiveUserWithPayload="payload"/>
  
// Хорошо

<MyComponent :is-green="name"/>
<MyComponent :has-active-user-with-payload="name"/>
```

- Именование компонентов. Всегда стараемся использовать CamelCase во всех проектах, любых компонентов. Если понимаем, что шаблон / скрипт в `.vue` компоненты становится слишком большим - не боимся разбивать их на несколько частей. Если компоненты семантически связаны между собой, то следует именовать их в определенном порядке - одно название должно вытекать из другого.

```tsx
// Плохо

components/
  vue-component.vue
  vueComponent.vue
  vue_component.vue

// Хорошо
components/
  VueComponent.vue
  BaseTableComponent.vue

```

В особых случаях, можно делать такую разбивку:

```tsx

components/
  VueComponent/
    VueComponent.vue
    VueComponent.ts

```

Если компоненты находятся рядом друг с другом, и имеют тесные связи между собой.

```tsx
// Плохо

components/
   TodoList.vue
   TodoItem.vue
   TodoButton.vue

components/
  SearchSidebar.vue
  NavigationForSearchSidebar.vue

// Хорошо

components/
  TodoList.vue
  TodoListItem.vue
  TodoListItemButton.vue
components/
  SearchSidebar.vue
  SearchSidebarNavigation.vue

```

## Как мы ведем проекты

Прежде чем начать разрабатывать тот или иной проект, мы должны пройти несколько стадий проекта, это

- Выработка требований
- Проектирование архитектуры
- Конструирование
- Тестирование системы
- Выпуск в продакшен (релиз)

В работе мы придерживаемся принципа - **семь раз отмерь, один раз отрежь.** Это значит, что все потенциальные проблемы должны быть решены до момента релиза продукта.

### Workflow - организовываем рабочее пространство

Для более удобной разработки проекта мы можем сопровождать наши проекты вспомогательные файлы, ниже небольшой список тех файлов, которые желательно иметь внутри проекта для более удобной настройки рабочего окружения.

**.editorconfig**

Это единый формат настроек, который позволяет и, раз и навсегда, решить вопросы вроде “табы или пробелы” для всех IDE и всех языков программирования. Такой файл может храниться в системе контроля версий проекта, что позволит всем его разработчикам использовать одну и ту же конфигурацию.

**.nvmrc**

NVM - это гибкий способ переключать версию компиляторы NodeJS в проекте (папке).

Если ваш проект очень сильно зависит от того, какая версия NodeJS установлена на компьютере, хорошо указать какая версия должна быть установлена для корректной работы проекта.

**README.md**

Сопроводительный документ к вашему проекту. Внутри хорошо иметь описания команд для сборки, и также аргументы (и их описание) которые мы используем при сборки.

**Сторонние библиотеки**

Мы стараемся минимизировать количество используемых библиотек в проекте. Это не означает, что чужое решение хуже своего. Напротив - чаще всего чужие решения лучше решают сложные задачи
за вас. Один из таких (хороших) примеров, это `axios`. Стандарный `XMLHttpRequest` имеет старое и неудобное API, а новый `window.fetch` не всегда подходит для решения тех или иных задач.

Безусловно, писать свой `http / websocket` клиент с нуля под отдельный проект - излишне, и таит в себе много проблем.

- Проблема с поддержкой, стандарты идут вперед - и поспевать за ними всегда не придется.
- Нужна хорошая документация, которая позволит любому человеку со стороны моментально понять как пользоваться вашей программой.
- Писать фундаментальные вещи вообще-то не просто, и много вещей можно упустить на этапе проектирования. А ваш проект решает другие задачи.

Open-source разработчики все эти проблемы будут решать за вас куда-более успешно.

Но, мы не приветствуем использование таких библиотек как `underscore` / `lodash`. Дело не в том что они плохие, а в том - что они вам и не нужны. 
